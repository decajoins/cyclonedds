// Copyright(c) 2020 to 2022 ZettaScale Technology and others
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0, or the Eclipse Distribution License
// v. 1.0 which is available at
// http://www.eclipse.org/org/documents/edl-v10.php.
//
// SPDX-License-Identifier: EPL-2.0 OR BSD-3-Clause

#include "dds/ddsrt/static_assert.h"
#include "dds/ddsi/ddsi_protocol.h"
#include "dds/ddsi/ddsi_log.h"
#include "dds/ddsi/ddsi_domaingv.h"
#include "ddsi__radmin.h"
#include "ddsi__misc.h"
#include "ddsi__xmsg.h"
#include "ddsi__bitset.h"
#include "ddsi__acknack.h"
#include "ddsi__entity_index.h"
#include "ddsi__proxy_endpoint.h"
#include "ddsi__endpoint_match.h"
#include "ddsi__security_omg.h"
#include "ddsi__xqos.h"
#include "ddsi__xevent.h"

#define ACK_REASON_IN_FLAGS 0

//根据已接收的数据的最新序列号 next_seq 和已经交付的数据的低32位序列号，计算下一个应该用于确认的交付序列号。
static ddsi_seqno_t next_deliv_seq (const struct ddsi_proxy_writer *pwr, const ddsi_seqno_t next_seq)
{
  /* We want to determine next_deliv_seq, the next sequence number to
     be delivered to all in-sync readers, so that we can acknowledge
     what we have actually delivered.  This is different from next_seq
     tracks, which tracks the sequence number up to which all samples
     have been received.  The difference is the delivery queue.

     There is always but a single delivery queue, and hence delivery
     thread, associated with a single proxy writer; but the ACKs are
     always generated by another thread.  Therefore, updates to
     next_deliv_seq need only be atomic with respect to these reads.
     On all supported platforms we can atomically load and store 32
     bits without issue, and so we store just the low word of the
     sequence number.

     We know 1 <= next_deliv_seq AND next_seq - N <= next_deliv_seq <=
     next_seq for N << 2**32.  With n = next_seq, nd = next_deliv_seq,
     H the upper half and L the lower half:

       - H(nd) <= H(n) <= H(nd)+1         { n >= nd AND N << 2*32}
       - H(n) = H(nd)   => L(n) >= L(nd)  { n >= nd }
       - H(n) = H(nd)+1 => L(n) < L(nd)   { N << 2*32 }

     Therefore:

       L(n) < L(nd) <=> H(n) = H(nd+1)

     a.k.a.:

       nd = nd' - if nd' > nd then 2**32 else 0
         where nd' = 2**32 * H(n) + L(nd)

     By not locking next_deliv_seq, we may have nd a bit lower than it
     could be, but that only means we are acknowledging slightly less
     than we could; but that is perfectly acceptible.

     FIXME: next_seq - #dqueue could probably be used instead,
     provided #dqueue is decremented after delivery, rather than
     before delivery. */
     //表示下一个交付序列号的低32位。
  const uint32_t lw = ddsrt_atomic_ld32 (&pwr->next_deliv_seq_lowword);
  //使用 next_seq 的高32位与加载的低32位，构建下一个交付序列号 next_deliv_seq。
  ddsi_seqno_t next_deliv_seq;
  next_deliv_seq = (next_seq & ~(uint64_t)UINT32_MAX) | lw;
  //如果 next_deliv_seq 大于 next_seq，表示高32位溢出，需要减去 2^32。这是因为序列号是64位的，而 next_deliv_seq 只包含了低32位。
  if (next_deliv_seq > next_seq)
    next_deliv_seq -= ((uint64_t) 1) << 32;
  assert (0 < next_deliv_seq && next_deliv_seq <= next_seq);
  return next_deliv_seq;
}

//该函数的目的是为 ACKNACK 消息构建序列号位图提供正确的源信息
static void add_acknack_getsource (const struct ddsi_proxy_writer *pwr, const struct ddsi_pwr_rd_match *rwn, struct ddsi_reorder **reorder, ddsi_seqno_t *bitmap_base, int *notail)
{
  /* if in sync, look at proxy writer status, else look at proxy-writer--reader match status */
  //检查代理写入者（pwr）与代理写入者-读取者匹配（rwn）的同步状态。如果不同步或者读取者被过滤，则使用not_in_sync 结构体的重新排序（reorder）。
  if (rwn->in_sync == PRMSS_OUT_OF_SYNC || rwn->filtered)
  {
    *reorder = rwn->u.not_in_sync.reorder;
    *bitmap_base = ddsi_reorder_next_seq (*reorder);
    *notail = 0;
  }
  //否则，使用代理写入者的重新排序对象 pwr->reorder
  else
  {
    *reorder = pwr->reorder;
    //如果不使用延迟确认模式，即 !pwr->e.gv->config.late_ack_mode，则直接使用重新排序对象的下一个序列号 ddsi_reorder_next_seq (*reorder) 作为位图的基础。
    if (!pwr->e.gv->config.late_ack_mode)
    {
      *bitmap_base = ddsi_reorder_next_seq (*reorder);
      //如果不使用延迟确认模式，即 !pwr->e.gv->config.late_ack_mode，或者读取者队列未满，即 ddsi_dqueue_is_full (pwr->dqueue) 返回 false，则将 *notail 设置为 0。
      *notail = 0;
    }
    //否则，调用之前提到的 next_deliv_seq 函数，使用代理写入者和重新排序对象的下一个序列号计算应该用于确认的下一个交付序列号
    else
    {
      *bitmap_base = next_deliv_seq (pwr, ddsi_reorder_next_seq (*reorder));
      //否则，将 *notail 设置为 1。
      *notail = ddsi_dqueue_is_full (pwr->dqueue);
    }
  }
}


/*


让我们假设有一个数据流，包含一系列按顺序到达的数据样本。每个样本由一个序列号（sequence number）和若干个片段（fragments）组成。

创建代理写入者（Proxy Writer）： 首先，我们创建一个代理写入者 pwr，该代理写入者维护了一些状态，如最后接收到的序列号 last_seq 和最后接收到的片段号 last_fragnum。
struct ddsi_pwr_rd_match rwn;
rwn.in_sync = PRMSS_IN_SYNC;   // 与读取者同步
rwn.filtered = false;          // 未被过滤

创建位图信息结构（AckNack Info）： 我们创建一个结构 info，用于存储生成的 ACKNACK 消息的位图信息以及可能的 NACKFRAG 信息。

struct ddsi_add_acknack_info info;
生成 ACKNACK 位图： 调用 add_acknack_makebitmaps 函数生成 ACKNACK 位图。

bool success = add_acknack_makebitmaps(&pwr, &rwn, &info);
在这个例子中，add_acknack_makebitmaps 函数会生成 ACKNACK 位图，该位图表示在代理写入者 pwr 和读取者匹配 rwn 之间存在的缺失序列号。假设生成的位图包含了缺失的序列号。

生成 NACKFRAG 信息： 如果存在缺失的序列号，会调用 ddsi_defrag_nackmap 函数生成 NACKFRAG 信息。

if (success && info.nackfrag.seq > 0) {
    // 生成 NACKFRAG 信息
    // info.nackfrag 包含了缺失的序列号及其对应的缺失片段信息
}
在这个例子中，info.nackfrag.seq 表示存在缺失的序列号，我们可以根据需要使用 info.nackfrag 中的信息生成 NACKFRAG。 

*/
//主要用于生成 ACKNACK 消息的序列号位图，并在有需要时生成 NACKFRAG
static bool add_acknack_makebitmaps (const struct ddsi_proxy_writer *pwr, const struct ddsi_pwr_rd_match *rwn, struct ddsi_add_acknack_info *info)
{
  struct ddsi_reorder *reorder;
  ddsi_seqno_t bitmap_base;
  int notail; /* notail = false: all known missing ones are nack'd */
  //获取源信息：调用 add_acknack_getsource 函数，获取应该用于构建位图的源信息，包括重新排序对象、位图基础和是否使用尾部标志。
  add_acknack_getsource (pwr, rwn, &reorder, &bitmap_base, &notail);

  /* Make bitmap; note that we've made sure to have room for the maximum bitmap size. */
  const ddsi_seqno_t last_seq = rwn->filtered ? rwn->last_seq : pwr->last_seq;
  //使用 ddsi_reorder_nackmap 函数生成序列号位图。此函数计算重新排序对象 reorder 中
  //从 bitmap_base 到 last_seq 之间的缺失序列号，并填充到 info->acknack.set 和 info->acknack.bits 中。如果所有位都是零，表示没有缺失的序列号，则返回 false。
  const uint32_t numbits = ddsi_reorder_nackmap (reorder, bitmap_base, last_seq, &info->acknack.set, info->acknack.bits, DDSI_SEQUENCE_NUMBER_SET_MAX_BITS, notail);
  if (numbits == 0)
  {
    info->nackfrag.seq = 0;
    return false;
  }

  /* Scan through bitmap, cutting it off at the first missing sample that the defragmenter
     knows about. Then note the sequence number & add a NACKFRAG for that sample */
     /*
     遍历生成的位图，对于每个缺失的序列号，调用 ddsi_defrag_nackmap 函数检查是否有缺失的片段。
    如果所有广告的片段都已知，则截断 ACKNACK 并返回 false。如果这是第一个样本，则将其截断为 ACK。
    如果有缺失的片段，则截断 ACKNACK，并生成 NACKFRAG，将缺失的序列号存储在 info->nackfrag.seq 中。
     */
  info->nackfrag.seq = 0;
  const ddsi_seqno_t base = ddsi_from_seqno (info->acknack.set.bitmap_base);
  for (uint32_t i = 0; i < numbits; i++)
  {
    if (!ddsi_bitset_isset (numbits, info->acknack.bits, i))
      continue;

    const ddsi_seqno_t seq = base + i;
    const uint32_t fragnum = (seq == pwr->last_seq) ? pwr->last_fragnum : UINT32_MAX;
    switch (ddsi_defrag_nackmap (pwr->defrag, seq, fragnum, &info->nackfrag.set, info->nackfrag.bits, DDSI_FRAGMENT_NUMBER_SET_MAX_BITS))
    {
      case DDSI_DEFRAG_NACKMAP_UNKNOWN_SAMPLE:
        break;
      case DDSI_DEFRAG_NACKMAP_ALL_ADVERTISED_FRAGMENTS_KNOWN:
        /* Cut the NACK short (or make it an ACK if this is the first sample), no NACKFRAG */
        info->nackfrag.seq = 0;
        info->acknack.set.numbits = i;
        return (i > 0);
      case DDSI_DEFRAG_NACKMAP_FRAGMENTS_MISSING:
        /* Cut the NACK short, NACKFRAG */
        info->nackfrag.seq = seq;
        info->acknack.set.numbits = i;
        return true;
    }
  }
  //返回 true 表示 ACKNACK 和（如果有的话）NACKFRAG 已经生成，可以发送给读取者。
  return true;
}

//这个函数的目的是在传输消息中生成 NACKFRAG 子消息。它构建了相应的数据结构，填充了相关字段，并追加到传输消息中。这样，当消息发送到读取者时，读取者将了解到缺失的片段信息，并可以请求重传。
static void add_NackFrag (struct ddsi_xmsg *msg, const struct ddsi_proxy_writer *pwr, const struct ddsi_pwr_rd_match *rwn, const struct ddsi_add_acknack_info *info)
{
  // 为 NACKFRAG 创建一个消息标记和数据结构
  struct ddsi_xmsg_marker sm_marker;
  ddsi_rtps_nackfrag_t *nf;

  // 确保有缺失的片段信息
  assert (info->nackfrag.set.numbits > 0 && info->nackfrag.set.numbits <= DDSI_FRAGMENT_NUMBER_SET_MAX_BITS);
  // 在消息中追加 NACKFRAG 数据
  nf = ddsi_xmsg_append (msg, &sm_marker, DDSI_NACKFRAG_SIZE (info->nackfrag.set.numbits));

  // 初始化消息的子消息
  ddsi_xmsg_submsg_init (msg, sm_marker, DDSI_RTPS_SMID_NACK_FRAG);
   // 设置 NACKFRAG 的相关字段
  nf->readerId = ddsi_hton_entityid (rwn->rd_guid.entityid);
  nf->writerId = ddsi_hton_entityid (pwr->e.guid.entityid);
  nf->writerSN = ddsi_to_seqno (info->nackfrag.seq);
#if ACK_REASON_IN_FLAGS
  nf->smhdr.flags |= info->flags;
#endif
  // We use 0-based fragment numbers, but externally have to provide 1-based fragment numbers */
  // 外部使用基于 1 的片段编号，但内部使用基于 0 的编号
  nf->fragmentNumberState.bitmap_base = info->nackfrag.set.bitmap_base + 1;
  nf->fragmentNumberState.numbits = info->nackfrag.set.numbits;
  memcpy (nf->bits, info->nackfrag.bits, DDSI_FRAGMENT_NUMBER_SET_BITS_SIZE (info->nackfrag.set.numbits));

  // Count field is at a variable offset ... silly DDSI spec
  // 在消息中添加计数字段
  ddsi_count_t * const countp =
    (ddsi_count_t *) ((char *) nf + offsetof (ddsi_rtps_nackfrag_t, bits) + DDSI_FRAGMENT_NUMBER_SET_BITS_SIZE (nf->fragmentNumberState.numbits));
  *countp = pwr->nackfragcount;

  // 设置消息的下一个子消息
  ddsi_xmsg_submsg_setnext (msg, sm_marker);

  // 如果启用了日志追踪，输出 NACKFRAG 信息
  if (pwr->e.gv->logconfig.c.mask & DDS_LC_TRACE)
  {
    ETRACE (pwr, "nackfrag #%"PRIu32":%"PRIu64"/%"PRIu32"/%"PRIu32":",
            pwr->nackfragcount, ddsi_from_seqno (nf->writerSN),
            nf->fragmentNumberState.bitmap_base, nf->fragmentNumberState.numbits);
    for (uint32_t ui = 0; ui != nf->fragmentNumberState.numbits; ui++)
      ETRACE (pwr, "%c", ddsi_bitset_isset (nf->fragmentNumberState.numbits, nf->bits, ui) ? '1' : '0');
  }

   // 在需要时对子消息进行编码
  // Encode the sub-message when needed
  ddsi_security_encode_datareader_submsg (msg, sm_marker, pwr, &rwn->rd_guid);
}

//这个函数负责构建 AckNack 子消息，其中包括读取者的标识、写入者的标识、读取者的序列号状态和缺失序列号的位图。这样，当消息传输到写入者时，写入者能够了解到读取者已经接收到哪些序列号的数据，以及读取者需要哪些序列号的数据。
static void add_acknack (struct ddsi_xmsg *msg, const struct ddsi_proxy_writer *pwr, const struct ddsi_pwr_rd_match *rwn, const struct ddsi_add_acknack_info *info)
{
  /* If pwr->have_seen_heartbeat == 0, no heartbeat has been received
     by this proxy writer yet, so we'll be sending a pre-emptive
     AckNack.  NACKing data now will most likely cause another NACK
     upon reception of the first heartbeat, and so cause the data to
     be resent twice. */
    // 如果 pwr->have_seen_heartbeat == 0，表示尚未接收到此代理写入者的心跳消息，因此会发送一个预先生成的 AckNack。
  ddsi_rtps_acknack_t *an;
  struct ddsi_xmsg_marker sm_marker;

// 在消息中追加 AckNack 数据
  an = ddsi_xmsg_append (msg, &sm_marker, DDSI_ACKNACK_SIZE_MAX);
  // 初始化消息的子消息
  ddsi_xmsg_submsg_init (msg, sm_marker, DDSI_RTPS_SMID_ACKNACK);
  // 设置 AckNack 的相关字段
  an->readerId = ddsi_hton_entityid (rwn->rd_guid.entityid);
  an->writerId = ddsi_hton_entityid (pwr->e.guid.entityid);

  // set FINAL flag late, in case it is decided that the "response_required" flag
  // should be set depending on the exact AckNack/NackFrag generated
  // 在消息的头部设置 FINAL 标志，以便在生成 AckNack/NackFrag 时可以根据需要设置 "response_required" 标志
  an->smhdr.flags |= DDSI_ACKNACK_FLAG_FINAL;
#if ACK_REASON_IN_FLAGS
  an->smhdr.flags |= info->flags;
#endif
 // 设置读取者序列号状态和位图
  an->readerSNState = info->acknack.set;
  memcpy (an->bits, info->acknack.bits, DDSI_SEQUENCE_NUMBER_SET_BITS_SIZE (an->readerSNState.numbits));

  // Count field is at a variable offset ... silly DDSI spec
    // 在消息中添加计数字段
  ddsi_count_t * const countp =
    (ddsi_count_t *) ((char *) an + offsetof (ddsi_rtps_acknack_t, bits) + DDSI_SEQUENCE_NUMBER_SET_BITS_SIZE (an->readerSNState.numbits));
  *countp = rwn->count;
  // Reset submessage size, now that we know the real size, and update the offset to the next submessage.
  // 重新设置子消息的大小，因为现在我们知道了实际大小，并更新到下一个子消息的偏移
  ddsi_xmsg_shrink (msg, sm_marker, DDSI_ACKNACK_SIZE (an->readerSNState.numbits));
  ddsi_xmsg_submsg_setnext (msg, sm_marker);

 // 如果启用了日志追踪，输出 AckNack 信息
  if (pwr->e.gv->logconfig.c.mask & DDS_LC_TRACE)
  {
    ETRACE (pwr, "acknack "PGUIDFMT" -> "PGUIDFMT": F#%"PRIu32":%"PRIu64"/%"PRIu32":",
            PGUID (rwn->rd_guid), PGUID (pwr->e.guid), rwn->count,
            ddsi_from_seqno (an->readerSNState.bitmap_base), an->readerSNState.numbits);
    for (uint32_t ui = 0; ui != an->readerSNState.numbits; ui++)
      ETRACE (pwr, "%c", ddsi_bitset_isset (an->readerSNState.numbits, an->bits, ui) ? '1' : '0');
  }

  // Encode the sub-message when needed
  // 在需要时对子消息进行编码
  ddsi_security_encode_datareader_submsg (msg, sm_marker, pwr, &rwn->rd_guid);
}

static enum ddsi_add_acknack_result get_acknack_info (const struct ddsi_proxy_writer *pwr, const struct ddsi_pwr_rd_match *rwn, struct ddsi_last_nack_summary *nack_summary, struct ddsi_add_acknack_info *info, bool ackdelay_passed, bool nackdelay_passed)
{
  /* If pwr->have_seen_heartbeat == 0, no heartbeat has been received
     by this proxy writer yet, so we'll be sending a pre-emptive
     AckNack.  NACKing data now will most likely cause another NACK
     upon reception of the first heartbeat, and so cause the data to
     be resent twice. */
      // 如果 pwr->have_seen_heartbeat == 0，表示尚未接收到此代理写入者的心跳消息，因此会发送一个预先生成的 AckNack。
  enum ddsi_add_acknack_result result;

#if ACK_REASON_IN_FLAGS
  info->flags = 0;
#endif
// 初始化 AckNack 信息结构体，并生成序列号位图和 NACKFRAG 信息
//调用 add_acknack_makebitmaps 函数生成 AckNack 的序列号位图和可能的 NACKFRAG 信息。
  if (!add_acknack_makebitmaps (pwr, rwn, info))
  {
    info->nack_sent_on_nackdelay = rwn->nack_sent_on_nackdelay;
    nack_summary->seq_base = ddsi_from_seqno (info->acknack.set.bitmap_base);
    nack_summary->seq_end_p1 = 0;
    nack_summary->frag_base = 0;
    nack_summary->frag_end_p1 = 0;
    result = AANR_ACK;
  }
   // 如果生成了 AckNack 信息，计算序列号和片段的范围，更新 nack_summary 结构体。
  else
  {
    // [seq_base:0 .. seq_end_p1:0) + [seq_end_p1:frag_base .. seq_end_p1:frag_end_p1) if frag_end_p1 > 0
    const ddsi_seqno_t seq_base = ddsi_from_seqno (info->acknack.set.bitmap_base);
    assert (seq_base >= 1 && (info->acknack.set.numbits > 0 || info->nackfrag.seq > 0));
    assert (info->nackfrag.seq == 0 || info->nackfrag.set.numbits > 0);
    const ddsi_seqno_t seq_end_p1 = seq_base + info->acknack.set.numbits;
    const uint32_t frag_base = (info->nackfrag.seq > 0) ? info->nackfrag.set.bitmap_base : 0;
    const uint32_t frag_end_p1 = (info->nackfrag.seq > 0) ? info->nackfrag.set.bitmap_base + info->nackfrag.set.numbits : 0;

    /* Let caller know whether it is a nack, and, in steady state, set
       final to prevent a response if it isn't.  The initial
       (pre-emptive) acknack is different: it'd be nice to get a
       heartbeat in response.

       Who cares about an answer to an acknowledgment!? -- actually,
       that'd a very useful feature in combination with directed
       heartbeats, or somesuch, to get reliability guarantees. */
        // 更新 nack_summary 结构体，记录序列号和片段的范围
    nack_summary->seq_end_p1 = seq_end_p1;
    nack_summary->frag_end_p1 = frag_end_p1;
    nack_summary->seq_base = seq_base;
    nack_summary->frag_base = frag_base;

    // [seq_base:0 .. seq_end_p1:0) and [seq_end_p1:frag_base .. seq_end_p1:frag_end_p1) if frag_end_p1 > 0
    if (seq_base > rwn->last_nack.seq_end_p1 || (seq_base == rwn->last_nack.seq_end_p1 && frag_base >= rwn->last_nack.frag_end_p1))
    {
      // A NACK for something not previously NACK'd or NackDelay passed, update nack_{seq,frag} to reflect
      // the changed state
      info->nack_sent_on_nackdelay = false;
#if ACK_REASON_IN_FLAGS
      info->flags = 0x10;
#endif
      result = AANR_NACK;
    }
    else if (rwn->directed_heartbeat && (!rwn->nack_sent_on_nackdelay || nackdelay_passed))
    {
      info->nack_sent_on_nackdelay = false;
#if ACK_REASON_IN_FLAGS
      info->flags = 0x20;
#endif
      result = AANR_NACK;
    }
    else if (nackdelay_passed)
    {
      info->nack_sent_on_nackdelay = true;
#if ACK_REASON_IN_FLAGS
      info->flags = 0x30;
#endif
      result = AANR_NACK;
    }
    else
    {
      // Overlap between this NACK and the previous one and NackDelay has not yet passed: clear numbits and
      // nackfrag_numbits to turn the NACK into an ACK and pretend to the caller nothing scary is going on.
#if ACK_REASON_IN_FLAGS
      info->flags = 0x40;
#endif
      info->nack_sent_on_nackdelay = rwn->nack_sent_on_nackdelay;
      info->acknack.set.numbits = 0;
      info->nackfrag.seq = 0;
      result = AANR_SUPPRESSED_NACK;
    }
  }

  if (result == AANR_ACK || result == AANR_SUPPRESSED_NACK)
  {
    // ACK and SUPPRESSED_NACK both end up being a pure ACK; send those only if we have to
    //22）	如果有ACK或者NACK要回，首先判断heartbeat_since_ack和ack_requested，这两个变量均在handle_Heartbeat_helper赋值，主要判断该心跳是否为Final标志，如果其中之一置1，则不会回ACK消息，返回AANR_SUPPRESSED_ACK
    if (!(rwn->heartbeat_since_ack && rwn->ack_requested))
      result = AANR_SUPPRESSED_ACK; // writer didn't ask for it
      //23）	如果本次回复的ACK的序列号比上一次还小，并且ackdelay_passed（本次心跳包时间-上一次回复ACK时间差<10ms，见步骤13分析），也不回复ACK报文
    else if (!(nack_summary->seq_base > rwn->last_nack.seq_base || ackdelay_passed))
      result = AANR_SUPPRESSED_ACK; // no progress since last, not enough time passed
  }
  else if (info->acknack.set.numbits == 0 && info->nackfrag.seq > 0 && !rwn->ack_requested)
  {
    // if we are not NACK'ing full samples and we are NACK'ing fragments, skip the ACKNACK submessage if we
    // have no interest in a HEARTBEAT and the writer hasn't asked for an ACKNACK since the last one we sent.
    result = AANR_NACKFRAG_ONLY;
  }
  return result;
}
/*
ddsi_sched_acknack_if_needed 是一个决策者，根据条件决定是否需要调度ACKNACK事件。
make_and_resched_acknack 是执行者，生成ACKNACK消息，更新状态和计数，并可能重新调度下一个ACKNACK事件。
*/


//根据一系列条件来决定是否要调度 ACKNACK 事件，以及何时调度.函数的执行流程受到 ACK 和 NACK 的延迟时间配置的影响，确保在适当的时间触发 ACKNACK 事件。
void ddsi_sched_acknack_if_needed (struct ddsi_xevent *ev, struct ddsi_proxy_writer *pwr, struct ddsi_pwr_rd_match *rwn, ddsrt_mtime_t tnow, bool avoid_suppressed_nack)
{
  /*
  这段注释解释了一段相对精确的代码，用于确定ACKNACK事件的行为。该代码考虑了多种情况，以确定是否需要重新安排ACKNACK事件。与此相反，另一种方法是通过简化逻辑来更积极地安排事件，然后在事件处理程序中抑制不必要的消息。

具体而言，相对精确的代码通过比较各种条件来决定是否需要重新安排ACKNACK事件。它考虑了以下情况：

获取源信息以确定ACKNACK事件的基本位图和序列号范围。
比较位图的基本序列号与读者的最后序列号以确定是否需要重新安排事件。
检查写者是否请求了ACKNACK以及自上次ACKNACK事件以来是否已发送心跳并且已请求ACKNACK。
检查是否自上次事件以来没有进展并且还没有足够的时间经过。
根据上述条件，决定是否重新安排ACKNACK事件。
相对精确的方法考虑了更多情况，并且在需要时更积极地安排事件。尽管有一些额外的开销，但它能够更精确地确定何时需要重新安排ACKNACK事件。相比之下，简化版本的方法更加激进，会更频繁地安排事件，但在事件处理程序中会抑制不必要的消息，因此它会更快地响应变化，但可能会产生一些不必要的事件。






  */
  // This is the relatively expensive and precise code to determine what the ACKNACK event will do,
  // the alternative is to do:
  //
  //   add_acknack_getsource (pwr, rwn, &reorder, &bitmap_base, &notail);
  //   const ddsi_seqno_t last_seq = rwn->filtered ? rwn->last_seq : pwr->last_seq;
  //   if (bitmap_base <= last_seq)
  //     (void) ddsi_resched_xevent_if_earlier (ev, tnow);
  //   else if (!(rwn->heartbeat_since_ack && rwn->ack_requested))
  //     ; // writer didn't ask for it
  //   else if (!(bitmap_base > rwn->last_nack.seq_base || ackdelay_passed))
  //     ; // no progress since last, not enough time passed
  //   else
  //    (void) ddsi_resched_xevent_if_earlier (ev, tnow);
  //
  // which is a stripped-down version of the same logic that more aggressively schedules the event,
  // relying on the event handler to suppress unnecessary messages.  There doesn't seem to be a big
  // downside to being precise.

  struct ddsi_domaingv * const gv = pwr->e.gv;
  //13）	Ackdelay_passed记录本次心跳包时间和上一次回复ACK时间间隔超过ack_delay(10ms)
//14）	Nackdelay_passed记录本次心跳包时间和上一次回复NACK时间间隔是否超过nack_delay(100ms)

  const bool ackdelay_passed = (tnow.v >= ddsrt_mtime_add_duration (rwn->t_last_ack, gv->config.ack_delay).v);
  const bool nackdelay_passed = (tnow.v >= ddsrt_mtime_add_duration (rwn->t_last_nack, gv->config.nack_delay).v);
  struct ddsi_add_acknack_info info;
  struct ddsi_last_nack_summary nack_summary;
  const enum ddsi_add_acknack_result aanr =
  //使用 get_acknack_info 函数获取 ACKNACK 信息，并根据结果来决定后续的操作。根据本次心跳包获取需要回复ACK还是NACK还是不回复
    get_acknack_info (pwr, rwn, &nack_summary, &info, ackdelay_passed, nackdelay_passed);
    //如果结果是 AANR_SUPPRESSED_ACK，则什么都不做，因为此时没有必要执行后续操作。
  if (aanr == AANR_SUPPRESSED_ACK)
    ; // nothing to be done now
    //如果需要避免抑制 NACK 且结果是 AANR_SUPPRESSED_NACK，则调度下一次事件的时间为上一次 NACK 时间加上 NACK 延迟时间。
  else if (avoid_suppressed_nack && aanr == AANR_SUPPRESSED_NACK)
    (void) ddsi_resched_xevent_if_earlier (ev, ddsrt_mtime_add_duration (rwn->t_last_nack, gv->config.nack_delay));
  else
  //对于其他情况，调度下一次事件的时间为当前时间
    (void) ddsi_resched_xevent_if_earlier (ev, tnow);
}

static struct ddsi_xmsg *make_and_resched_acknack (struct ddsi_xevent *ev, struct ddsi_proxy_writer *pwr, struct ddsi_pwr_rd_match *rwn, ddsrt_mtime_t tnow, bool avoid_suppressed_nack)
{
  struct ddsi_domaingv * const gv = pwr->e.gv;
  //存储生成的 ACKNACK 消息的指针。
  struct ddsi_xmsg *msg;
  //存储 ACKNACK 信息的结构体 (struct ddsi_add_acknack_info)
  struct ddsi_add_acknack_info info;

  // 存储上一次 NACK 摘要信息的结构体 (struct ddsi_last_nack_summary)。
  struct ddsi_last_nack_summary nack_summary;
  //通过调用 get_acknack_info 函数获取的 enum ddsi_add_acknack_result 类型的结果
  const enum ddsi_add_acknack_result aanr =
    get_acknack_info (pwr, rwn, &nack_summary, &info,
                      tnow.v >= ddsrt_mtime_add_duration (rwn->t_last_ack, gv->config.ack_delay).v,
                      tnow.v >= ddsrt_mtime_add_duration (rwn->t_last_nack, gv->config.nack_delay).v);
  //不需要ack
  if (aanr == AANR_SUPPRESSED_ACK)
    return NULL;
    //如果避免发送被抑制的 NACK（avoid_suppressed_nack 为真且 aanr 为 AANR_SUPPRESSED_NACK），则将事件重新调度，并返回 NULL
  else if (avoid_suppressed_nack && aanr == AANR_SUPPRESSED_NACK)
  {
    (void) ddsi_resched_xevent_if_earlier (ev, ddsrt_mtime_add_duration (rwn->t_last_nack, gv->config.nack_delay));
    return NULL;
  }
  //如果既没有收到 HEARTBEAT 也没有收到 HEARTBEATFRAG，且 aanr 不是 AANR_ACK，则返回 NULL。这是按照规范不允许发送 ACKNACK 的情况，但在某些情况下，可能会从规范中偏离以恢复由于不对称断开引起的数据包丢失。
  else if (!(rwn->heartbeat_since_ack || rwn->heartbeatfrag_since_ack))
  {
    // Not really allowed to send an ACKNACK by the spec, except we do it sometimes to recover
    // from packet loss after an asymmetrical disconnect where the writer never has any reason
    // to send a heartbeat
    switch (aanr)
    {
      case AANR_SUPPRESSED_ACK:
        // handled above
        assert (0);
      case AANR_ACK:
        // we only break the rules if we need retransmits
        return NULL;
      case AANR_NACK:
      case AANR_NACKFRAG_ONLY:
      case AANR_SUPPRESSED_NACK:
        // suppress these spontaneous NACKs if they be more frequent than the auto-resched nack_delay
        if (tnow.v < ddsrt_mtime_add_duration (rwn->t_last_nack, gv->config.auto_resched_nack_delay).v)
        {
          (void) ddsi_resched_xevent_if_earlier (ev, ddsrt_mtime_add_duration (rwn->t_last_nack, gv->config.auto_resched_nack_delay));
          return NULL;
        }
        break;
    }
 }

  // Committing to sending a message in response: update the state.  Note that there's still a
  // possibility of not sending a message, but that is only in case of failures of some sort.
  // Resetting the flags and bailing out simply means we will wait until the next heartbeat to
  // do try again.
  //重置状态标志，包括 directed_heartbeat，heartbeat_since_ack，heartbeatfrag_since_ack，nack_sent_on_nackdelay
  rwn->directed_heartbeat = 0;
  rwn->heartbeat_since_ack = 0;
  rwn->heartbeatfrag_since_ack = 0;
  rwn->nack_sent_on_nackdelay = (info.nack_sent_on_nackdelay ? 1 : 0);

//获取相关的参与者信息（如果代理写入者启用了安全特性)
  struct ddsi_participant *pp = NULL;
  if (ddsi_omg_proxy_participant_is_secure (pwr->c.proxypp))
  {
    struct ddsi_reader *rd = ddsi_entidx_lookup_reader_guid (pwr->e.gv->entity_index, &rwn->rd_guid);
    if (rd)
      pp = rd->c.pp;
  }

//创建一个新的 ACKNACK 消息 (msg)，其中消息的大小限制为 DDSI_ACKNACK_SIZE_MAX，类型为 DDSI_XMSG_KIND_CONTROL
  if ((msg = ddsi_xmsg_new (gv->xmsgpool, &rwn->rd_guid, pp, DDSI_ACKNACK_SIZE_MAX, DDSI_XMSG_KIND_CONTROL)) == NULL)
  {
    return NULL;
  }

  ddsi_xmsg_setdst_pwr (msg, pwr);
  //如果启用了 HB->ACK 的延迟测量 (meas_hb_to_ack_latency)，并且存在 HEARTBEAT 的时间戳，则将时间戳添加到消息中。
  if (gv->config.meas_hb_to_ack_latency && rwn->hb_timestamp.v)
  {
    // If HB->ACK latency measurement is enabled, and we have a
    // timestamp available, add it and clear the time stamp.  There
    // is no real guarantee that the two match, but I haven't got a
    // solution for that yet ...  If adding the time stamp fails,
    // too bad, but no reason to get worried. */
    ddsi_xmsg_add_timestamp (msg, rwn->hb_timestamp);
    rwn->hb_timestamp.v = 0;
  }

  //调用 add_acknack 函数生成 ACKNACK 消息。
  if (aanr != AANR_NACKFRAG_ONLY)
    add_acknack (msg, pwr, rwn, &info);
  if (info.nackfrag.seq > 0)
  {
    ETRACE (pwr, " + ");
    //如果包含 NACKFRAG 信息，调用 add_NackFrag 函数生成 NACKFRAG 消息
    add_NackFrag (msg, pwr, rwn, &info);
  }
  ETRACE (pwr, "\n");
  //如果生成的消息大小为零，表示尝试编码消息时出现问题，释放消息并返回 NULL。
  if (ddsi_xmsg_size (msg) == 0)
  {
    // attempt at encoding the message caused it to be dropped
    ddsi_xmsg_free (msg);
    return NULL;
  }

//更新 rwn 的计数。
  rwn->count++;
  //根据结果更新状态和调度下一个事件,根据 aanr 的值，更新 rwn 的状态和计数。
  switch (aanr)
  {
    case AANR_SUPPRESSED_ACK:
      // no message: caught by the size = 0 check
      assert (0);
      break;
          //如果是 AANR_ACK，重置 ack_requested，更新 t_last_ack，并更新 last_nack.seq_base。
    case AANR_ACK:
      rwn->ack_requested = 0;
      rwn->t_last_ack = tnow;
      rwn->last_nack.seq_base = nack_summary.seq_base;
      break;
      //如果是 AANR_NACK 或 AANR_NACKFRAG_ONLY，更新相应的状态，以及 last_nack 和 t_last_nack，并在一些条件下自动调度下一个 NACK 事件。
    case AANR_NACK:
    case AANR_NACKFRAG_ONLY:
      if (nack_summary.frag_end_p1 != 0)
        pwr->nackfragcount++;
      if (aanr != AANR_NACKFRAG_ONLY)
      {
        rwn->ack_requested = 0;
        rwn->t_last_ack = tnow;
      }
      rwn->last_nack = nack_summary;
      rwn->t_last_nack = tnow;
      /* If NACKing, make sure we don't give up too soon: even though
       we're not allowed to send an ACKNACK unless in response to a
       HEARTBEAT, I've seen too many cases of not sending an NACK
       because the writing side got confused ...  Better to recover
       eventually. */
      (void) ddsi_resched_xevent_if_earlier (ev, ddsrt_mtime_add_duration (tnow, gv->config.auto_resched_nack_delay));
      break;
    case AANR_SUPPRESSED_NACK:
    //如果是 AANR_SUPPRESSED_NACK，重置 ack_requested，更新 t_last_ack，并重新调度下一个 NACK 事件
      rwn->ack_requested = 0;
      rwn->t_last_ack = tnow;
      rwn->last_nack.seq_base = nack_summary.seq_base;
      (void) ddsi_resched_xevent_if_earlier (ev, ddsrt_mtime_add_duration (rwn->t_last_nack, gv->config.nack_delay));
      break;
  }
  //输出跟踪日志，表示已发送 ACKNACK。
  GVTRACE ("send acknack(rd "PGUIDFMT" -> pwr "PGUIDFMT")\n", PGUID (rwn->rd_guid), PGUID (pwr->e.guid));
  //返回生成的 ACKNACK 消息 (msg)。如果没有生成消息，返回 NULL。
  return msg;
}

static dds_duration_t preemptive_acknack_interval (const struct ddsi_pwr_rd_match *rwn)
{
  if (rwn->t_last_ack.v < rwn->tcreate.v)
    return 0;
  else
  {
    const dds_duration_t age = rwn->t_last_ack.v - rwn->tcreate.v;
    if (age <= DDS_SECS (10))
      return DDS_SECS (1);
    else if (age <= DDS_SECS (60))
      return DDS_SECS (2);
    else if (age <= DDS_SECS (120))
      return DDS_SECS (5);
    else
      return DDS_SECS (10);
  }
}

static struct ddsi_xmsg *make_preemptive_acknack (struct ddsi_xevent *ev, struct ddsi_proxy_writer *pwr, struct ddsi_pwr_rd_match *rwn, ddsrt_mtime_t tnow)
{
  const dds_duration_t old_intv = preemptive_acknack_interval (rwn);
  //通过比较当前时间tnow与上次发送ACKNACK消息的时间加上旧的间隔时间old_intv之和，来确定是否已经到了发送新的ACKNACK消息的时间。
  if (tnow.v < ddsrt_mtime_add_duration (rwn->t_last_ack, old_intv).v)
  {
    //然后，检查当前时间tnow是否已经超过了上次发送ACKNACK消息的时间加上旧的间隔时间old_intv。如果未超过，则将事件重新安排到下一次发送ACKNACK消息的时间，并返回NULL。
    (void) ddsi_resched_xevent_if_earlier (ev, ddsrt_mtime_add_duration (rwn->t_last_ack, old_intv));
    return NULL;
  }

  struct ddsi_domaingv * const gv = pwr->e.gv;
  struct ddsi_participant *pp = NULL;
  if (ddsi_omg_proxy_participant_is_secure (pwr->c.proxypp))
  {
    struct ddsi_reader *rd = ddsi_entidx_lookup_reader_guid (gv->entity_index, &rwn->rd_guid);
    if (rd)
      pp = rd->c.pp;
  }
//如果当前时间已经超过了预先发送ACKNACK消息的时间，则创建新的ACKNACK消息。创建过程包括初始化消息，并设置消息的目标代理写者和读者，填充ACKNACK消息的相关信息，如读者ID、写者ID、序列号状态等。
  struct ddsi_xmsg *msg;
  if ((msg = ddsi_xmsg_new (gv->xmsgpool, &rwn->rd_guid, pp, DDSI_ACKNACK_SIZE_MAX, DDSI_XMSG_KIND_CONTROL)) == NULL)
  {
    // if out of memory, try again later
    (void) ddsi_resched_xevent_if_earlier (ev, ddsrt_mtime_add_duration (tnow, old_intv));
    return NULL;
  }

  ddsi_xmsg_setdst_pwr (msg, pwr);
  struct ddsi_xmsg_marker sm_marker;
  ddsi_rtps_acknack_t *an = ddsi_xmsg_append (msg, &sm_marker, DDSI_ACKNACK_SIZE (0));
  ddsi_xmsg_submsg_init (msg, sm_marker, DDSI_RTPS_SMID_ACKNACK);
  an->readerId = ddsi_hton_entityid (rwn->rd_guid.entityid);
  an->writerId = ddsi_hton_entityid (pwr->e.guid.entityid);
  an->readerSNState.bitmap_base = ddsi_to_seqno (1);
  an->readerSNState.numbits = 0;
  ddsi_count_t * const countp =
    (ddsi_count_t *) ((char *) an + offsetof (ddsi_rtps_acknack_t, bits) + DDSI_SEQUENCE_NUMBER_SET_BITS_SIZE (0));
  *countp = 0;
  ddsi_xmsg_submsg_setnext (msg, sm_marker);
  ddsi_security_encode_datareader_submsg (msg, sm_marker, pwr, &rwn->rd_guid);

  rwn->t_last_ack = tnow;
  const dds_duration_t new_intv = preemptive_acknack_interval (rwn);
  (void) ddsi_resched_xevent_if_earlier (ev, ddsrt_mtime_add_duration (rwn->t_last_ack, new_intv));

  // numbits is always 0 here, so need to print the bitmap
  //最后，更新读者上次发送ACKNACK消息的时间，计算新的预先发送ACKNACK消息的间隔时间，并将事件重新安排到下一次发送ACKNACK消息的时间。同时打印日志以记录生成的ACKNACK消息的相关信息
  ETRACE (pwr, "acknack "PGUIDFMT" -> "PGUIDFMT": #%"PRIu32":%"PRId64"/%"PRIu32":\n",
          PGUID (rwn->rd_guid), PGUID (pwr->e.guid), *countp,
          ddsi_from_seqno (an->readerSNState.bitmap_base), an->readerSNState.numbits);
  return msg;
}

/*
make_preemptive_acknack 和 make_and_resched_acknack 都是用于创建并调度 ACKNACK 消息的函数，但它们的调用场景和目的略有不同。

make_preemptive_acknack:

调用场景： 该函数用于在尚未收到来自 Proxy Writer 的心跳（Heartbeat）之前主动创建并发送 ACKNACK 消息。这通常发生在 Proxy Writer 尚未启动或在短时间内未发送心跳的情况下，Reader 通过主动发送 ACKNACK 来请求未接收到的数据。
目的： 为了尽早地获取尚未接收的数据，Reader 在没有明确的心跳信息的情况下采取主动措施。
make_and_resched_acknack:

调用场景： 该函数用于在收到 Proxy Writer 的心跳后创建并调度 ACKNACK 消息。这是在正常的数据传输过程中，Reader 响应 Proxy Writer 的心跳，通知它已经接收到哪些数据。
目的： 为了维护数据的一致性，Reader 根据接收到的心跳信息定期发送 ACKNACK，以告知 Proxy Writer 关于数据的接收情况。
在总体设计中，make_preemptive_acknack 用于主动请求数据，而 make_and_resched_acknack 用于响应来自 Proxy Writer 的心跳。这两者共同确保了数据的及时传输和一致性。
*/
void ddsi_acknack_xevent_cb (struct ddsi_domaingv *gv, struct ddsi_xevent *ev, struct ddsi_xpack *xp, void *varg, ddsrt_mtime_t tnow)
{
  /* FIXME: ought to keep track of which NACKs are being generated in
     response to a Heartbeat.  There is no point in having multiple
     readers NACK the data.

     FIXME: ought to determine the set of missing samples (as it does
     now), and then check which for of those fragments are available already.
     A little snag is that the defragmenter can throw out partial samples in
     favour of others, so MUST ensure that the defragmenter won't start
     threshing and fail to make progress! */
  struct ddsi_acknack_xevent_cb_arg const * const arg = varg;
  struct ddsi_proxy_writer *pwr;
  struct ddsi_xmsg *msg;
  struct ddsi_pwr_rd_match *rwn;

  if ((pwr = ddsi_entidx_lookup_proxy_writer_guid (gv->entity_index, &arg->pwr_guid)) == NULL)
  {
    return;
  }

  ddsrt_mutex_lock (&pwr->e.lock);
  if ((rwn = ddsrt_avl_lookup (&ddsi_pwr_readers_treedef, &pwr->readers, &arg->rd_guid)) == NULL)
  {
    ddsrt_mutex_unlock (&pwr->e.lock);
    return;
  }

  if (!pwr->have_seen_heartbeat)
    msg = make_preemptive_acknack (ev, pwr, rwn, tnow);
  else
  //主要用于生成ACKNACK消息，以及更新相应的状态和计数。
// 调用get_acknack_info函数获取ACKNACK信息，然后根据信息生成ACKNACK消息，包括可能的NACKFRAG信息。
// 在生成ACKNACK消息后，更新相关的状态和计数，然后根据生成的消息大小决定是否继续执行后续操作。
// 如果需要，重新调度下一个事件，通常是ACKNACK事件或NACK事件。
    msg = make_and_resched_acknack (ev, pwr, rwn, tnow, false);
  ddsrt_mutex_unlock (&pwr->e.lock);

  /* ddsi_xpack_addmsg may sleep (for bandwidth-limited channels), so
     must be outside the lock */
  if (msg)
  {
    // a possible result of trying to encode a submessage is that it is removed,
    // in which case we may end up with an empty one.
    // FIXME: change ddsi_security_encode_datareader_submsg so that it returns this and make it warn_unused_result
    if (ddsi_xmsg_size (msg) == 0)
      ddsi_xmsg_free (msg);
    else
      ddsi_xpack_addmsg (xp, msg, 0);
  }
}
